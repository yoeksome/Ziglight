###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         08/Jun/2017  11:43:51 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\Source\List1.c                    #
#    Command line       =  -f E:\work\smartlight\ZigLight001\Projects\zstack\ #
#                          Samples\ZigLightApp\CC2530DB\..\..\..\Tools\CC2530 #
#                          DB\f8wCoord.cfg (-DCPU32MHZ -DROOT=__near_func     #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f E:\work\smartlight\ZigLight001\Projects\zstack\ #
#                          Samples\ZigLightApp\CC2530DB\..\..\..\Tools\CC2530 #
#                          DB\f8wConfig.cfg (-DZIGBEEPRO -DSECURE=0           #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFF00                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 E:\work\smartlight\ZigLight #
#                          001\Projects\zstack\Samples\ZigLightApp\Source\Lis #
#                          t1.c -D ZTOOL_P1 -D NV_RESTORE -D MWK_MANAGER -D   #
#                          xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D        #
#                          xLCD_SUPPORTED=DEBUG -lC                           #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\CoordinatorEB\List\ -lA  #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\CoordinatorEB\List\      #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\CoordinatorEB\Obj\ -e    #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\work\smartlight\ZigLight001\Projects\zstack\ #
#                          Samples\ZigLightApp\CC2530DB\ -I                   #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\..\Source\ -I            #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\..\..\..\ZMain\TI2530DB\ #
#                           -I E:\work\smartlight\ZigLight001\Projects\zstack #
#                          \Samples\ZigLightApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\hal\include\ -I E:\work\smartlight\ZigLight0 #
#                          01\Projects\zstack\Samples\ZigLightApp\CC2530DB\.. #
#                          \..\..\..\..\Components\hal\target\CC2530EB\ -I    #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\..\..\..\..\..\Component #
#                          s\mac\include\ -I E:\work\smartlight\ZigLight001\P #
#                          rojects\zstack\Samples\ZigLightApp\CC2530DB\..\..\ #
#                          ..\..\..\Components\mac\high_level\ -I             #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\..\..\..\..\..\Component #
#                          s\mac\low_level\srf04\ -I                          #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\..\..\..\..\..\Component #
#                          s\mac\low_level\srf04\single_chip\ -I              #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\..\..\..\..\..\Component #
#                          s\mt\ -I E:\work\smartlight\ZigLight001\Projects\z #
#                          stack\Samples\ZigLightApp\CC2530DB\..\..\..\..\..\ #
#                          Components\osal\include\ -I                        #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\..\..\..\..\..\Component #
#                          s\services\saddr\ -I E:\work\smartlight\ZigLight00 #
#                          1\Projects\zstack\Samples\ZigLightApp\CC2530DB\..\ #
#                          ..\..\..\..\Components\services\sdata\ -I          #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\..\..\..\..\..\Component #
#                          s\stack\af\ -I E:\work\smartlight\ZigLight001\Proj #
#                          ects\zstack\Samples\ZigLightApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\stack\nwk\ -I                     #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\..\..\..\..\..\Component #
#                          s\stack\sapi\ -I E:\work\smartlight\ZigLight001\Pr #
#                          ojects\zstack\Samples\ZigLightApp\CC2530DB\..\..\. #
#                          .\..\..\Components\stack\sec\ -I                   #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\..\..\..\..\..\Component #
#                          s\stack\sys\ -I E:\work\smartlight\ZigLight001\Pro #
#                          jects\zstack\Samples\ZigLightApp\CC2530DB\..\..\.. #
#                          \..\..\Components\stack\zdo\ -I                    #
#                          E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\..\..\..\..\..\Component #
#                          s\zmac\ -I E:\work\smartlight\ZigLight001\Projects #
#                          \zstack\Samples\ZigLightApp\CC2530DB\..\..\..\..\. #
#                          .\Components\zmac\f8w\ -Ohz --require_prototypes   #
#    List file          =  E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\CoordinatorEB\List\List1 #
#                          .lst                                               #
#    Object file        =  E:\work\smartlight\ZigLight001\Projects\zstack\Sam #
#                          ples\ZigLightApp\CC2530DB\CoordinatorEB\Obj\List1. #
#                          r51                                                #
#                                                                             #
#                                                                             #
###############################################################################

E:\work\smartlight\ZigLight001\Projects\zstack\Samples\ZigLightApp\Source\List1.c
      1          
      2          #include "List1.h"
      3          #include "mt_uart.h"
      4          #include "ZDProfile.h"
      5          #include "ZDApp.h"
      6          extern Node *nodelist;
      7          extern Node *deletnodelist;
      8          extern uint8 newdevice_joinin;//新O浼尤苏I =0耸炯尤氤鲥e =1加入成功

   \                                 In  segment XDATA_Z, align 1, keep-with-next
      9          uint8 currentMac[8];
   \                     currentMac:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     10          uint8 NewMacUpate=0;//by liu
   \                     NewMacUpate:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     11          extern uint8 ZDAppTaskID;
     12          /* 1.初始化线性表，即置单链表的表头指针为空 */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     13          void initList(Node **pNode)
   \                     initList:
     14          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
     15          //  uint8 i;
     16            *pNode = NULL;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   E4           CLR     A
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   F0           MOVX    @DPTR,A
     17          //  pNode = (Node *)osal_mem_alloc(sizeof(Node)); //申请新节点
     18            (*pNode)->next = NULL;
   \   00000C   90000E       MOV     DPTR,#0xe
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   F0           MOVX    @DPTR,A
     19            (*pNode)->prior = NULL;
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   12....       LCALL   ?Subroutine2 & 0xFFFF
     20          //  for(i=0;i<8;i++)
     21          //    pNode->extaddr[i] = 0;
     22          //  pNode->heartbeatCnt = 0;
     23          //  pNode->heartbeatCntOld = 0;
     24          //  pNode->detectHeartbeatCnt = 0;
     25            //pruint8f("initList函数执行，初始化成功\n");
     26          }
   \                     ??CrossCallReturnLabel_13:
   \   000019                REQUIRE ?Subroutine0
   \   000019                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2410         ADD     A,#0x10
   \   000003                REQUIRE ??Subroutine13_0
   \   000003                ; // Fall through to label ??Subroutine13_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine13_0:
   \   000000   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000003   A3           INC     DPTR
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   3400         ADDC    A,#0x0
   \   000005   F9           MOV     R1,A
   \   000006   8882         MOV     DPL,R0
   \   000008   8983         MOV     DPH,R1
   \   00000A   E4           CLR     A
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   22           RET
     27           
     28          /* 2.创建线性表，此函数输入负数终止读取数据*/
     29          //Node *creatList(Node *pHead , uint8 * extaddr)
     30          //{
     31          //  Node *p1,*p2;
     32          //  p2 = pHead;
     33          //  while(p2->next != NULL)
     34          //    p2 = p2->next;
     35          //  p1=(Node *)osal_mem_alloc(sizeof(Node)); //申请新节点
     36          //  if(p1 == NULL)
     37          //  {
     38          //    //pruint8f("内存分配失败\n");
     39          //    return 0;
     40          //  }
     41          //  p2->next = p1;
     42          //  osal_memcmp(p1->extaddr,extaddr,8);
     43          //  
     44          //  p1->next = NULL;         //新节点的指针置为空
     45          //
     46          //  return pHead;           //返回链表的头指针
     47          //}
     48           
     49          /* 3.打印链表，链表的遍历*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     50          Node* searchfromList(Node *pHead , uint8 * extaddr)
   \                     searchfromList:
     51          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   8C..         MOV     ?V0 + 0,R4
   \   000007   8D..         MOV     ?V0 + 1,R5
     52            Node *p1;
     53            p1 = pHead;
   \   000009   EA           MOV     A,R2
   \   00000A   FE           MOV     R6,A
   \   00000B   EB           MOV     A,R3
   \   00000C   FF           MOV     R7,A
     54            if(NULL == p1)   //链表为空
   \   00000D   EE           MOV     A,R6
   \   00000E   4F           ORL     A,R7
   \   00000F   7014         JNZ     ??searchfromList_0
     55            {
     56              //pruint8f("Pruint8List函数执行，链表为空\n");
     57              return NULL;
   \                     ??searchfromList_1:
   \   000011   7A00         MOV     R2,#0x0
   \   000013   7B00         MOV     R3,#0x0
   \   000015   804A         SJMP    ??searchfromList_2
     58            }
     59            else
     60            {
     61              while(NULL != p1)
     62              {
     63                if(osal_memcmp(p1->extaddr,extaddr,8) == true){
     64                  p1->heartbeatCnt++;
     65                  return p1;
     66                }
     67                p1 = p1->next;
   \                     ??searchfromList_3:
   \   000017   EE           MOV     A,R6
   \   000018   240E         ADD     A,#0xe
   \   00001A   F582         MOV     DPL,A
   \   00001C   EF           MOV     A,R7
   \   00001D   12....       LCALL   ??Subroutine15_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000020   E0           MOVX    A,@DPTR
   \   000021   FE           MOV     R6,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   FF           MOV     R7,A
   \                     ??searchfromList_0:
   \   000025   EE           MOV     A,R6
   \   000026   4F           ORL     A,R7
   \   000027   60E8         JZ      ??searchfromList_1
   \   000029                ; Setup parameters for call to function osal_memcmp
   \   000029   85....       MOV     ?V0 + 4,?V0 + 0
   \   00002C   85....       MOV     ?V0 + 5,?V0 + 1
   \   00002F   75..00       MOV     ?V0 + 6,#0x0
   \   000032   78..         MOV     R0,#?V0 + 4
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000037   7C08         MOV     R4,#0x8
   \   000039   7D00         MOV     R5,#0x0
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   A3           INC     DPTR
   \   000040   A982         MOV     R1,DPL
   \   000042   AA83         MOV     R2,DPH
   \   000044   7B00         MOV     R3,#0x0
   \   000046   12....       LCALL   ??osal_memcmp?relay
   \   000049   7403         MOV     A,#0x3
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004E   E9           MOV     A,R1
   \   00004F   6401         XRL     A,#0x1
   \   000051   70C4         JNZ     ??searchfromList_3
   \   000053   EE           MOV     A,R6
   \   000054   240B         ADD     A,#0xb
   \   000056   F582         MOV     DPL,A
   \   000058   EF           MOV     A,R7
   \   000059   12....       LCALL   ??Subroutine14_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   EE           MOV     A,R6
   \   00005E   FA           MOV     R2,A
   \   00005F   EF           MOV     A,R7
   \   000060   FB           MOV     R3,A
   \                     ??searchfromList_2:
   \   000061   7F07         MOV     R7,#0x7
   \   000063   02....       LJMP    ?BANKED_LEAVE_XDATA
     68              }
     69              return NULL;
     70            }
     71          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine14_0:
   \   000000   12....       LCALL   ??Subroutine15_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   04           INC     A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine15_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   22           RET
     72           

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     73          Node* searchshortaddfromList(Node *pHead , uint16  shortaddr)
   \                     searchshortaddfromList:
     74          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
     75            Node *p1;
     76            p1 = pHead;
     77            if(NULL == p1)   //链表为空
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   7012         JNZ     ??CrossCallReturnLabel_34
     78            {
     79              //pruint8f("Pruint8List函数执行，链表为空\n");
     80              return NULL;
   \                     ??searchshortaddfromList_0:
   \   000008   7A00         MOV     R2,#0x0
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   8030         SJMP    ??searchshortaddfromList_1
     81            }
     82            else
     83            {
     84              while(NULL != p1)
     85              {
     86                if(p1->shortaddr == shortaddr){
     87                  p1->heartbeatCnt++;
     88                  return p1;
     89                }
     90                p1 = p1->next;
   \                     ??searchshortaddfromList_2:
   \   00000E   EA           MOV     A,R2
   \   00000F   240E         ADD     A,#0xe
   \   000011   F582         MOV     DPL,A
   \   000013   EB           MOV     A,R3
   \   000014   12....       LCALL   ??Subroutine15_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000017   12....       LCALL   ??Subroutine17_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   60EA         JZ      ??searchshortaddfromList_0
   \   00001E   8A82         MOV     DPL,R2
   \   000020   8B83         MOV     DPH,R3
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   6C           XRL     A,R4
   \   00002D   7003         JNZ     ??searchshortaddfromList_3
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   6D           XRL     A,R5
   \                     ??searchshortaddfromList_3:
   \   000032   70DA         JNZ     ??searchshortaddfromList_2
   \   000034   EA           MOV     A,R2
   \   000035   240B         ADD     A,#0xb
   \   000037   F582         MOV     DPL,A
   \   000039   EB           MOV     A,R3
   \   00003A   12....       LCALL   ??Subroutine14_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   00003D   F0           MOVX    @DPTR,A
     91              }
     92              return NULL;
     93            }
   \                     ??searchshortaddfromList_1:
   \   00003E   02....       LJMP    ?Subroutine0 & 0xFFFF
     94          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine17_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
     95          /* 4.清除线性表L中的所有元素，即释放单链表L中所有的结点，使之成为一个空表 */
     96          //void clearList(Node *pHead)
     97          //{
     98          //  Node *pNext;            //定义一个与pHead相邻节点
     99          //  
    100          //  if(pHead == NULL)
    101          //  {
    102          //    //pruint8f("clearList函数执行，链表为空\n");
    103          //    return;
    104          //  }
    105          //  while(pHead->next != NULL)
    106          //  {
    107          //    pNext = pHead->next;//保存下一结点的指针
    108          //    osal_mem_free(pHead);
    109          //    pHead = pNext;      //表头下移
    110          //  }
    111          //  //pruint8f("clearList函数执行，链表已经清除\n");
    112          //}
    113           
    114          /* 5.返回单链表的长度 */
    115          //uint8 sizeList(Node *pHead)
    116          //{
    117          //  uint8 size = 0;
    118          //  
    119          //  while(pHead != NULL)
    120          //  {
    121          //    size++;         //遍历链表size大小比链表的实际长度小1
    122          //    pHead = pHead->next;
    123          //  }
    124          //  return size;    //链表的实际长度
    125          //}
    126           
    127          /* 6.检查单链表是否为空，若为空则返回１，否则返回０ */
    128          //uint8 isEmptyList(Node *pHead)
    129          //{
    130          //  if(pHead == NULL)
    131          //  {
    132          //    //pruint8f("isEmptyList函数执行，链表为空\n");
    133          //    return 1;
    134          //  }
    135          //  //pruint8f("isEmptyList函数执行，链表非空\n");
    136          //  
    137          //  return 0;
    138          //}
    139           
    140          /* 7.返回单链表中第pos个结点中的元素，若pos超出范围，则停止程序运行 */
    141          //elemType getElement(Node *pHead, uint8 pos)
    142          //{
    143          //  uint8 i=0;
    144          //  
    145          //  if(pos < 1)
    146          //  {
    147          //    //        pruint8f("getElement函数执行，pos值非法\n");
    148          //    return 0;
    149          //  }
    150          //  if(pHead == NULL)
    151          //  {
    152          //    //        pruint8f("getElement函数执行，链表为空\n");
    153          //    return 0;
    154          //    //exit(1);
    155          //  }
    156          //  while(pHead !=NULL)
    157          //  {
    158          //    ++i;
    159          //    if(i == pos)
    160          //    {
    161          //      break;
    162          //    }
    163          //    pHead = pHead->next; //移到下一结点
    164          //  }
    165          //  if(i < pos)                  //链表长度不足则退出
    166          //  {
    167          //    //        pruint8f("getElement函数执行，pos值超出链表长度\n");
    168          //    return 0;
    169          //  }
    170          //  
    171          //  return pHead->element;
    172          //}
    173          
    174          /* 8.从单链表中查找具有给定值x的第一个元素，若查找成功则返回该结点data域的存储地址，否则返回NULL */
    175          //elemType *getElemAddr(Node *pHead, elemType x)
    176          //{
    177          //    if(NULL == pHead)
    178          //    {
    179          ////        pruint8f("getElemAddr函数执行，链表为空\n");
    180          //        return NULL;
    181          //    }
    182          //    if(x < 0)
    183          //    {
    184          ////        pruint8f("getElemAddr函数执行，给定值X不合法\n");
    185          //        return NULL;
    186          //    }
    187          //    while((pHead->element != x) && (NULL != pHead->next)) //判断是否到链表末尾，以及是否存在所要找的元素
    188          //    {
    189          //        pHead = pHead->next;
    190          //    }
    191          //    if((pHead->element != x) && (pHead != NULL))
    192          //    {
    193          ////        pruint8f("getElemAddr函数执行，在链表中未找到x值\n");
    194          //        return NULL;
    195          //    }
    196          //    if(pHead->element == x)
    197          //    {
    198          ////        pruint8f("getElemAddr函数执行，元素 %d 的地址为 0x%x\n",x,&(pHead->element));
    199          //    }
    200          // 
    201          //    return &(pHead->element);//返回元素的地址
    202          //}
    203           
    204          /* 9.把单链表中第pos个结点的值修改为x的值，若修改成功返回１，否则返回０ */
    205          //uint8 modifyElem(Node *pNode,uint8 pos,elemType x)
    206          //{
    207          //    Node *pHead;
    208          //    pHead = pNode;
    209          //    uint8 i = 0;
    210          // 
    211          //    if(NULL == pHead)
    212          //    {
    213          ////        pruint8f("modifyElem函数执行，链表为空\n");
    214          //    }
    215          //    if(pos < 1)
    216          //    {
    217          ////        pruint8f("modifyElem函数执行，pos值非法\n");
    218          //        return 0;
    219          //    }
    220          //    while(pHead !=NULL)
    221          //    {
    222          //        ++i;
    223          //        if(i == pos)
    224          //        {
    225          //            break;
    226          //        }
    227          //        pHead = pHead->next; //移到下一结点
    228          //    }
    229          //    if(i < pos)                  //链表长度不足则退出
    230          //    {
    231          ////        pruint8f("modifyElem函数执行，pos值超出链表长度\n");
    232          //        return 0;
    233          //    }
    234          //    pNode = pHead;
    235          //    pNode->element = x;
    236          ////    pruint8f("modifyElem函数执行\n");
    237          //     
    238          //    return 1;
    239          //}
    240           
    241          /* 10.向单链表的表头插入一个元素 */
    242          //uint8 insertHeadList(Node **pNode,elemType insertElem)
    243          //{
    244          //  Node *pInsert;
    245          //  pInsert = (Node *)osal_mem_alloc(sizeof(Node));
    246          //  osal_memset(pInsert,0,sizeof(Node));
    247          //  pInsert->element = insertElem;
    248          //  pInsert->next = *pNode;
    249          //  *pNode = pInsert;
    250          //  //pruint8f("insertHeadList函数执行，向表头插入元素成功\n");
    251          //  
    252          //  return 1;
    253          //}
    254          
    255          /* 11.向单链表的末尾添加一个元素 */
    256          //uint8 insertLastList(Node *pNode,elemType insertElem)
    257          //{
    258          //  Node *pInsert;
    259          //  Node *pHead;
    260          //  Node *pTmp; //定义一个临时链表用来存放第一个节点
    261          //  
    262          //  pHead = pNode;
    263          //  pTmp = pHead;
    264          //  pInsert = (Node *)osal_mem_alloc(sizeof(Node)); //申请一个新节点
    265          //  osal_memset(pInsert,0,sizeof(Node));
    266          //  pInsert->element = insertElem;
    267          //  
    268          //  while(pHead->next != NULL)
    269          //  {
    270          //    pHead = pHead->next;
    271          //  }
    272          //  pHead->next = pInsert;   //将链表末尾节点的下一结点指向新添加的节点
    273          ////  pNode = pTmp;
    274          //  //pruint8f("insertLastList函数执行，向表尾插入元素成功\n");
    275          //  
    276          //  return 1;
    277          //}
    278          
    279          /************
    280          * insertLastList 
    281          * 担 pHeadl^； extaddrOmac
    282          * 返回：0不能分配空g添加O湫畔，1成功添加O
    283          ***************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    284          uint8 insertLastList(Node **pHead , uint8 * extaddr , uint16 shortAddr)
   \                     insertLastList:
    285          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   8C..         MOV     ?V0 + 12,R4
   \   000010   8D..         MOV     ?V0 + 13,R5
   \   000012   7426         MOV     A,#0x26
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 4,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 5,A
    286            uint8 asc_16[16]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   AC82         MOV     R4,DPL
   \   000026   AD83         MOV     R5,DPH
   \   000028   7583..       MOV     DPH,#(`?<Constant {48, 49, 50, 51, 52, 53, 54, 55, 56` >> 8) & 0xff
   \   00002B   7582..       MOV     DPL,#`?<Constant {48, 49, 50, 51, 52, 53, 54, 55, 56` & 0xff
   \   00002E   7410         MOV     A,#0x10
   \   000030   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    287            uint8 i;
    288            Node *p1,*p2,*tp;
    289            p2 = *pHead;
   \   000033   8A82         MOV     DPL,R2
   \   000035   8B83         MOV     DPH,R3
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F8           MOV     R0,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F9           MOV     R1,A
   \   00003C   88..         MOV     ?V0 + 2,R0
   \   00003E   89..         MOV     ?V0 + 3,R1
    290            tp = p2;
   \   000040   88..         MOV     ?V0 + 6,R0
   \   000042   F5..         MOV     ?V0 + 7,A
    291            if(*pHead == NULL){
   \   000044   E8           MOV     A,R0
   \   000045   49           ORL     A,R1
   \   000046   6003         JZ      $+5
   \   000048   02....       LJMP    ??insertLastList_0 & 0xFFFF
    292              (*pHead)=(Node *)osal_mem_alloc(sizeof(Node)); //申请新节点
   \   00004B                ; Setup parameters for call to function osal_mem_alloc
   \   00004B   7A12         MOV     R2,#0x12
   \   00004D   7B00         MOV     R3,#0x0
   \   00004F   12....       LCALL   ??osal_mem_alloc?relay
   \   000052   85..82       MOV     DPL,?V0 + 0
   \   000055   85..83       MOV     DPH,?V0 + 1
   \   000058   EA           MOV     A,R2
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   A3           INC     DPTR
   \   00005B   EB           MOV     A,R3
   \   00005C   12....       LCALL   ?Subroutine4 & 0xFFFF
    293              if((*pHead) == NULL)
   \                     ??CrossCallReturnLabel_4:
   \   00005F   E8           MOV     A,R0
   \   000060   49           ORL     A,R1
   \   000061   7019         JNZ     ??insertLastList_1
    294              {
    295                //pruint8f("内存分配失败\n");
    296                HalUARTWrite(0,"\r\nlist memalloc error",21);
   \                     ??insertLastList_2:
   \   000063                ; Setup parameters for call to function HalUARTWrite
   \   000063   7C15         MOV     R4,#0x15
   \   000065   7D00         MOV     R5,#0x0
   \   000067   7A..         MOV     R2,#`?<Constant "\\r\\nlist memalloc error">` & 0xff
   \   000069   7B..         MOV     R3,#(`?<Constant "\\r\\nlist memalloc error">` >> 8) & 0xff
   \   00006B   7900         MOV     R1,#0x0
   \   00006D   12....       LCALL   ??HalUARTWrite?relay
    297                return 2;         //返回error
   \   000070   7902         MOV     R1,#0x2
   \                     ??insertLastList_3:
   \   000072   7410         MOV     A,#0x10
   \   000074   12....       LCALL   ?DEALLOC_XSTACK8
   \   000077   7F0E         MOV     R7,#0xe
   \   000079   02....       LJMP    ?BANKED_LEAVE_XDATA
    298              }
    299              (*pHead)->element = 1;
   \                     ??insertLastList_1:
   \   00007C   85..82       MOV     DPL,?V0 + 0
   \   00007F   85..83       MOV     DPH,?V0 + 1
   \   000082   A3           INC     DPTR
   \   000083   E0           MOVX    A,@DPTR
   \   000084   F583         MOV     DPH,A
   \   000086   8882         MOV     DPL,R0
   \   000088   7401         MOV     A,#0x1
   \   00008A   12....       LCALL   ?Subroutine4 & 0xFFFF
    300              (*pHead)->shortaddr = shortAddr;
   \                     ??CrossCallReturnLabel_5:
   \   00008D   8882         MOV     DPL,R0
   \   00008F   8983         MOV     DPH,R1
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   E5..         MOV     A,?V0 + 4
   \   00009C   F0           MOVX    @DPTR,A
   \   00009D   A3           INC     DPTR
   \   00009E   E5..         MOV     A,?V0 + 5
   \   0000A0   F0           MOVX    @DPTR,A
    301              (*pHead)->heartbeatCnt = 0;
   \   0000A1   E8           MOV     A,R0
   \   0000A2   240B         ADD     A,#0xb
   \   0000A4   F582         MOV     DPL,A
   \   0000A6   E9           MOV     A,R1
   \   0000A7   12....       LCALL   ??Subroutine16_0 & 0xFFFF
    302              (*pHead)->heartbeatCntOld = 0;
   \                     ??CrossCallReturnLabel_21:
   \   0000AA   85..82       MOV     DPL,?V0 + 0
   \   0000AD   85..83       MOV     DPH,?V0 + 1
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   240C         ADD     A,#0xc
   \   0000B3   12....       LCALL   ?Subroutine3 & 0xFFFF
    303              (*pHead)->detectHeartbeatCnt = 0;
   \                     ??CrossCallReturnLabel_2:
   \   0000B6   240D         ADD     A,#0xd
   \   0000B8   12....       LCALL   ?Subroutine3 & 0xFFFF
    304              (*pHead)->next = NULL;
   \                     ??CrossCallReturnLabel_3:
   \   0000BB   240E         ADD     A,#0xe
   \   0000BD   12....       LCALL   ??Subroutine13_0 & 0xFFFF
    305              (*pHead)->prior = NULL;
   \                     ??CrossCallReturnLabel_12:
   \   0000C0   85..82       MOV     DPL,?V0 + 0
   \   0000C3   85..83       MOV     DPH,?V0 + 1
   \   0000C6   12....       LCALL   ?Subroutine2 & 0xFFFF
    306              osal_memcpy((*pHead)->extaddr,extaddr,8);
   \                     ??CrossCallReturnLabel_14:
   \   0000C9                ; Setup parameters for call to function osal_memcpy
   \   0000C9   85....       MOV     ?V0 + 4,?V0 + 12
   \   0000CC   85....       MOV     ?V0 + 5,?V0 + 13
   \   0000CF   F5..         MOV     ?V0 + 6,A
   \   0000D1   78..         MOV     R0,#?V0 + 4
   \   0000D3   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D6   7C08         MOV     R4,#0x8
   \   0000D8   7D00         MOV     R5,#0x0
   \   0000DA   85..82       MOV     DPL,?V0 + 0
   \   0000DD   85..83       MOV     DPH,?V0 + 1
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   2401         ADD     A,#0x1
   \   0000E3   FA           MOV     R2,A
   \   0000E4   A3           INC     DPTR
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   3400         ADDC    A,#0x0
   \   0000E8   FB           MOV     R3,A
   \   0000E9   12....       LCALL   ??osal_memcpy?relay
   \   0000EC   7403         MOV     A,#0x3
   \   0000EE   12....       LCALL   ?DEALLOC_XSTACK8
    307              if(1)//uart test
    308              {
    309                HalUARTWrite(0,"\nA:",3);
   \   0000F1                ; Setup parameters for call to function HalUARTWrite
   \   0000F1   7C03         MOV     R4,#0x3
   \   0000F3   7D00         MOV     R5,#0x0
   \   0000F5   7A..         MOV     R2,#`?<Constant "\\nA:">` & 0xff
   \   0000F7   7B..         MOV     R3,#(`?<Constant "\\nA:">` >> 8) & 0xff
   \   0000F9   7900         MOV     R1,#0x0
   \   0000FB   12....       LCALL   ??HalUARTWrite?relay
    310                for(i=0;i<8;i++)
   \   0000FE   75..00       MOV     ?V0 + 0,#0x0
    311                {
    312                  HalUARTWrite(0,&asc_16[extaddr[i]%256/16],1);
   \                     ??insertLastList_4:
   \   000101   12....       LCALL   ?Subroutine1 & 0xFFFF
    313                  HalUARTWrite(0,&asc_16[extaddr[i]%16],1);  
    314                }
   \                     ??CrossCallReturnLabel_0:
   \   000104   40FB         JC      ??insertLastList_4
    315                HalUARTWrite(0,"\n",1);
   \                     ??insertLastList_5:
   \   000106                ; Setup parameters for call to function HalUARTWrite
   \   000106   7C01         MOV     R4,#0x1
   \   000108   7D00         MOV     R5,#0x0
   \   00010A   7A..         MOV     R2,#`?<Constant "\\n">` & 0xff
   \   00010C   7B..         MOV     R3,#(`?<Constant "\\n">` >> 8) & 0xff
   \   00010E   7900         MOV     R1,#0x0
   \   000110   12....       LCALL   ??HalUARTWrite?relay
    316              }
    317              NewMacUpate = 1;
   \   000113   90....       MOV     DPTR,#NewMacUpate
   \   000116   7401         MOV     A,#0x1
   \   000118   F0           MOVX    @DPTR,A
    318              return 1;           //返回ok
   \   000119   F9           MOV     R1,A
   \   00011A   02....       LJMP    ??insertLastList_3 & 0xFFFF
    319            }
    320            while(p2->next != NULL)
    321              p2 = p2->next;
   \                     ??insertLastList_6:
   \   00011D   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000120   F5..         MOV     ?V0 + 2,A
   \   000122   A3           INC     DPTR
   \   000123   E0           MOVX    A,@DPTR
   \   000124   F5..         MOV     ?V0 + 3,A
   \                     ??insertLastList_0:
   \   000126   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000129   F8           MOV     R0,A
   \   00012A   A3           INC     DPTR
   \   00012B   E0           MOVX    A,@DPTR
   \   00012C   F9           MOV     R1,A
   \   00012D   E8           MOV     A,R0
   \   00012E   49           ORL     A,R1
   \   00012F   70EC         JNZ     ??insertLastList_6
    322            p1=(Node *)osal_mem_alloc(sizeof(Node)); //申请新节点
   \   000131                ; Setup parameters for call to function osal_mem_alloc
   \   000131   7A12         MOV     R2,#0x12
   \   000133   7B00         MOV     R3,#0x0
   \   000135   12....       LCALL   ??osal_mem_alloc?relay
   \   000138   8A..         MOV     ?V0 + 8,R2
   \   00013A   8B..         MOV     ?V0 + 9,R3
   \   00013C   AE..         MOV     R6,?V0 + 8
   \   00013E   AF..         MOV     R7,?V0 + 9
    323            if(p1 == NULL)
   \   000140   EE           MOV     A,R6
   \   000141   4F           ORL     A,R7
   \   000142   7003         JNZ     $+5
   \   000144   02....       LJMP    ??insertLastList_2 & 0xFFFF
    324            {
    325              //pruint8f("内存分配失败\n");
    326              HalUARTWrite(0,"\r\nlist memalloc error",21);
    327              return 2;         //返回error
    328            }
    329            p1->element = 1;
   \   000147   8E82         MOV     DPL,R6
   \   000149   8F83         MOV     DPH,R7
   \   00014B   7401         MOV     A,#0x1
   \   00014D   F0           MOVX    @DPTR,A
    330            p1->shortaddr = shortAddr;
   \   00014E   A3           INC     DPTR
   \   00014F   A3           INC     DPTR
   \   000150   A3           INC     DPTR
   \   000151   A3           INC     DPTR
   \   000152   A3           INC     DPTR
   \   000153   A3           INC     DPTR
   \   000154   A3           INC     DPTR
   \   000155   A3           INC     DPTR
   \   000156   A3           INC     DPTR
   \   000157   E5..         MOV     A,?V0 + 4
   \   000159   F0           MOVX    @DPTR,A
   \   00015A   A3           INC     DPTR
   \   00015B   E5..         MOV     A,?V0 + 5
   \   00015D   F0           MOVX    @DPTR,A
    331            p1->heartbeatCnt = 0;
   \   00015E   EE           MOV     A,R6
   \   00015F   240B         ADD     A,#0xb
   \   000161   12....       LCALL   ?Subroutine6 & 0xFFFF
    332            p1->heartbeatCntOld = 0;
   \                     ??CrossCallReturnLabel_22:
   \   000164   EE           MOV     A,R6
   \   000165   240C         ADD     A,#0xc
   \   000167   12....       LCALL   ?Subroutine6 & 0xFFFF
    333            p1->detectHeartbeatCnt = 0;
   \                     ??CrossCallReturnLabel_23:
   \   00016A   EE           MOV     A,R6
   \   00016B   240D         ADD     A,#0xd
   \   00016D   12....       LCALL   ?Subroutine6 & 0xFFFF
    334            p2->next = p1;
   \                     ??CrossCallReturnLabel_24:
   \   000170   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000173   EE           MOV     A,R6
   \   000174   F0           MOVX    @DPTR,A
   \   000175   A3           INC     DPTR
   \   000176   EF           MOV     A,R7
   \   000177   F0           MOVX    @DPTR,A
    335            p1->prior = p2;
   \   000178   EE           MOV     A,R6
   \   000179   2410         ADD     A,#0x10
   \   00017B   F582         MOV     DPL,A
   \   00017D   EF           MOV     A,R7
   \   00017E   12....       LCALL   ??Subroutine15_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000181   E5..         MOV     A,?V0 + 2
   \   000183   F0           MOVX    @DPTR,A
   \   000184   A3           INC     DPTR
   \   000185   E5..         MOV     A,?V0 + 3
   \   000187   F0           MOVX    @DPTR,A
    336            osal_memcpy(p1->extaddr,extaddr,8);
   \   000188                ; Setup parameters for call to function osal_memcpy
   \   000188   85....       MOV     ?V0 + 8,?V0 + 12
   \   00018B   85....       MOV     ?V0 + 9,?V0 + 13
   \   00018E   75..00       MOV     ?V0 + 10,#0x0
   \   000191   78..         MOV     R0,#?V0 + 8
   \   000193   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000196   7C08         MOV     R4,#0x8
   \   000198   7D00         MOV     R5,#0x0
   \   00019A   8E82         MOV     DPL,R6
   \   00019C   8F83         MOV     DPH,R7
   \   00019E   A3           INC     DPTR
   \   00019F   AA82         MOV     R2,DPL
   \   0001A1   AB83         MOV     R3,DPH
   \   0001A3   12....       LCALL   ??osal_memcpy?relay
   \   0001A6   7403         MOV     A,#0x3
   \   0001A8   12....       LCALL   ?DEALLOC_XSTACK8
    337            
    338            p1->next = NULL;         //新节点的指针置为空
   \   0001AB   EE           MOV     A,R6
   \   0001AC   240E         ADD     A,#0xe
   \   0001AE   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0001B1   A3           INC     DPTR
   \   0001B2   F0           MOVX    @DPTR,A
    339            *pHead = tp;
   \   0001B3   85..82       MOV     DPL,?V0 + 0
   \   0001B6   85..83       MOV     DPH,?V0 + 1
   \   0001B9   E5..         MOV     A,?V0 + 6
   \   0001BB   F0           MOVX    @DPTR,A
   \   0001BC   A3           INC     DPTR
   \   0001BD   E5..         MOV     A,?V0 + 7
   \   0001BF   F0           MOVX    @DPTR,A
    340            if(1)//uart test
    341            {
    342              HalUARTWrite(0,"\nA:",3);
   \   0001C0                ; Setup parameters for call to function HalUARTWrite
   \   0001C0   7C03         MOV     R4,#0x3
   \   0001C2   7D00         MOV     R5,#0x0
   \   0001C4   7A..         MOV     R2,#`?<Constant "\\nA:">` & 0xff
   \   0001C6   7B..         MOV     R3,#(`?<Constant "\\nA:">` >> 8) & 0xff
   \   0001C8   7900         MOV     R1,#0x0
   \   0001CA   12....       LCALL   ??HalUARTWrite?relay
    343              for(i=0;i<8;i++)
   \   0001CD   75..00       MOV     ?V0 + 0,#0x0
    344              {
    345                HalUARTWrite(0,&asc_16[extaddr[i]%256/16],1);
   \                     ??insertLastList_7:
   \   0001D0   12....       LCALL   ?Subroutine1 & 0xFFFF
    346                HalUARTWrite(0,&asc_16[extaddr[i]%16],1);  
    347              }
    348              HalUARTWrite(0,"\n",1);
    349            }
   \                     ??CrossCallReturnLabel_1:
   \   0001D3   4003         JC      $+5
   \   0001D5   02....       LJMP    ??insertLastList_5 & 0xFFFF
   \   0001D8   80F6         SJMP    ??insertLastList_7
    350            NewMacUpate = 1;
    351            return 1;           //返回ok
    352          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E5..         MOV     A,?V0 + 2
   \   000002   240E         ADD     A,#0xe
   \   000004   F582         MOV     DPL,A
   \   000006   E5..         MOV     A,?V0 + 3
   \   000008                REQUIRE ??Subroutine15_0
   \   000008                ; // Fall through to label ??Subroutine15_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   F582         MOV     DPL,A
   \   000002   EF           MOV     A,R7
   \   000003                REQUIRE ??Subroutine16_0
   \   000003                ; // Fall through to label ??Subroutine16_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine16_0:
   \   000000   12....       LCALL   ??Subroutine15_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000003   E4           CLR     A
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0 + 0
   \   000004   85..83       MOV     DPH,?V0 + 1
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F8           MOV     R0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000003   85..82       MOV     DPL,?V0 + 0
   \   000006   85..83       MOV     DPH,?V0 + 1
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   85....       MOV     ?V0 + 2,?V0 + 0
   \   000003   E5..         MOV     A,?V0 + 12
   \   000005   25..         ADD     A,?V0 + 2
   \   000007   FE           MOV     R6,A
   \   000008   E5..         MOV     A,?V0 + 13
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   FF           MOV     R7,A
   \   00000D                ; Setup parameters for call to function HalUARTWrite
   \   00000D                ; Setup parameters for call to function HalUARTWrite
   \   00000D   7C01         MOV     R4,#0x1
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   E0           MOVX    A,@DPTR
   \   000016   C4           SWAP    A
   \   000017   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00001A                ; Setup parameters for call to function HalUARTWrite
   \   00001A                ; Setup parameters for call to function HalUARTWrite
   \   00001A   7C01         MOV     R4,#0x1
   \   00001C   7D00         MOV     R5,#0x0
   \   00001E   8E82         MOV     DPL,R6
   \   000020   8F83         MOV     DPH,R7
   \   000022   E0           MOVX    A,@DPTR
   \   000023   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000026   05..         INC     ?V0 + 0
   \   000028   E5..         MOV     A,?V0 + 0
   \   00002A   C3           CLR     C
   \   00002B   9408         SUBB    A,#0x8
   \   00002D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   540F         ANL     A,#0xf
   \   000002   F8           MOV     R0,A
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   E582         MOV     A,DPL
   \   00000B   28           ADD     A,R0
   \   00000C   FA           MOV     R2,A
   \   00000D   E583         MOV     A,DPH
   \   00000F   3400         ADDC    A,#0x0
   \   000011   FB           MOV     R3,A
   \   000012   7900         MOV     R1,#0x0
   \   000014   12....       LCALL   ??HalUARTWrite?relay
   \   000017   22           RET
    353          #pragma optimize=none

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    354          uint8 detectHandle(Node **pNode)//三秒扫描一次 如果计数超过MAX_MISS_HEARTBEAT_CNT的设备将被移除list并串口发送出设备mac信息
   \                     detectHandle:
    355          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    356          //  uint8 asc_16[16]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
    357          //  uint8 i;
    358            Node *p1,*p2,*p3;
    359            p1 = *pNode;
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F8           MOV     R0,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F9           MOV     R1,A
   \   000012   E8           MOV     A,R0
   \   000013   FA           MOV     R2,A
   \   000014   E9           MOV     A,R1
   \   000015   FB           MOV     R3,A
    360            p2 = p1;
   \   000016   8A..         MOV     ?V0 + 0,R2
   \   000018   8B..         MOV     ?V0 + 1,R3
    361            while(p1 != NULL){
   \                     ??detectHandle_0:
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??detectHandle_1 & 0xFFFF
    362              if(p1->heartbeatCnt == p1->heartbeatCntOld)
   \   000021   EA           MOV     A,R2
   \   000022   240B         ADD     A,#0xb
   \   000024   F582         MOV     DPL,A
   \   000026   EB           MOV     A,R3
   \   000027   3400         ADDC    A,#0x0
   \   000029   F583         MOV     DPH,A
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F8           MOV     R0,A
   \   00002D   EA           MOV     A,R2
   \   00002E   240C         ADD     A,#0xc
   \   000030   F582         MOV     DPL,A
   \   000032   EB           MOV     A,R3
   \   000033   3400         ADDC    A,#0x0
   \   000035   F583         MOV     DPH,A
   \   000037   E0           MOVX    A,@DPTR
   \   000038   68           XRL     A,R0
   \   000039   7010         JNZ     ??detectHandle_2
    363                p1->detectHeartbeatCnt++;
   \   00003B   EA           MOV     A,R2
   \   00003C   240D         ADD     A,#0xd
   \   00003E   F582         MOV     DPL,A
   \   000040   EB           MOV     A,R3
   \   000041   3400         ADDC    A,#0x0
   \   000043   F583         MOV     DPH,A
   \   000045   E0           MOVX    A,@DPTR
   \   000046   2401         ADD     A,#0x1
   \   000048   F0           MOVX    @DPTR,A
   \   000049   8027         SJMP    ??detectHandle_3
    364              else{
    365                p1->heartbeatCntOld = p1->heartbeatCnt;
   \                     ??detectHandle_2:
   \   00004B   EA           MOV     A,R2
   \   00004C   240B         ADD     A,#0xb
   \   00004E   F582         MOV     DPL,A
   \   000050   EB           MOV     A,R3
   \   000051   3400         ADDC    A,#0x0
   \   000053   F583         MOV     DPH,A
   \   000055   E0           MOVX    A,@DPTR
   \   000056   C0E0         PUSH    A
   \   000058   EA           MOV     A,R2
   \   000059   240C         ADD     A,#0xc
   \   00005B   F582         MOV     DPL,A
   \   00005D   EB           MOV     A,R3
   \   00005E   3400         ADDC    A,#0x0
   \   000060   F583         MOV     DPH,A
   \   000062   D0E0         POP     A
   \   000064   F0           MOVX    @DPTR,A
    366                p1->detectHeartbeatCnt = 0;
   \   000065   EA           MOV     A,R2
   \   000066   240D         ADD     A,#0xd
   \   000068   F582         MOV     DPL,A
   \   00006A   EB           MOV     A,R3
   \   00006B   3400         ADDC    A,#0x0
   \   00006D   F583         MOV     DPH,A
   \   00006F   7400         MOV     A,#0x0
   \   000071   F0           MOVX    @DPTR,A
    367              }
    368              if(p1->detectHeartbeatCnt >= MAX_MISS_HEARTBEAT_CNT){
   \                     ??detectHandle_3:
   \   000072   EA           MOV     A,R2
   \   000073   240D         ADD     A,#0xd
   \   000075   F582         MOV     DPL,A
   \   000077   EB           MOV     A,R3
   \   000078   3400         ADDC    A,#0x0
   \   00007A   F583         MOV     DPH,A
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   C3           CLR     C
   \   00007E   9403         SUBB    A,#0x3
   \   000080   5003         JNC     $+5
   \   000082   02....       LJMP    ??detectHandle_4 & 0xFFFF
    369                p1->detectHeartbeatCnt = 0;
   \   000085   EA           MOV     A,R2
   \   000086   240D         ADD     A,#0xd
   \   000088   F582         MOV     DPL,A
   \   00008A   EB           MOV     A,R3
   \   00008B   3400         ADDC    A,#0x0
   \   00008D   F583         MOV     DPH,A
   \   00008F   7400         MOV     A,#0x0
   \   000091   F0           MOVX    @DPTR,A
    370                p1->prior->next = p1->next;
   \   000092   EA           MOV     A,R2
   \   000093   240E         ADD     A,#0xe
   \   000095   F582         MOV     DPL,A
   \   000097   EB           MOV     A,R3
   \   000098   3400         ADDC    A,#0x0
   \   00009A   F583         MOV     DPH,A
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   F5..         MOV     ?V0 + 2,A
   \   00009F   A3           INC     DPTR
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   F5..         MOV     ?V0 + 3,A
   \   0000A3   EA           MOV     A,R2
   \   0000A4   2410         ADD     A,#0x10
   \   0000A6   F582         MOV     DPL,A
   \   0000A8   EB           MOV     A,R3
   \   0000A9   3400         ADDC    A,#0x0
   \   0000AB   F583         MOV     DPH,A
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   240E         ADD     A,#0xe
   \   0000B0   F8           MOV     R0,A
   \   0000B1   A3           INC     DPTR
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   3400         ADDC    A,#0x0
   \   0000B5   F9           MOV     R1,A
   \   0000B6   8882         MOV     DPL,R0
   \   0000B8   8983         MOV     DPH,R1
   \   0000BA   E5..         MOV     A,?V0 + 2
   \   0000BC   F0           MOVX    @DPTR,A
   \   0000BD   A3           INC     DPTR
   \   0000BE   E5..         MOV     A,?V0 + 3
   \   0000C0   F0           MOVX    @DPTR,A
    371                p1->next->prior = p1->prior;
   \   0000C1   EA           MOV     A,R2
   \   0000C2   2410         ADD     A,#0x10
   \   0000C4   F582         MOV     DPL,A
   \   0000C6   EB           MOV     A,R3
   \   0000C7   3400         ADDC    A,#0x0
   \   0000C9   F583         MOV     DPH,A
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   F5..         MOV     ?V0 + 2,A
   \   0000CE   A3           INC     DPTR
   \   0000CF   E0           MOVX    A,@DPTR
   \   0000D0   F5..         MOV     ?V0 + 3,A
   \   0000D2   EA           MOV     A,R2
   \   0000D3   240E         ADD     A,#0xe
   \   0000D5   F582         MOV     DPL,A
   \   0000D7   EB           MOV     A,R3
   \   0000D8   3400         ADDC    A,#0x0
   \   0000DA   F583         MOV     DPH,A
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   2410         ADD     A,#0x10
   \   0000DF   F8           MOV     R0,A
   \   0000E0   A3           INC     DPTR
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   3400         ADDC    A,#0x0
   \   0000E4   F9           MOV     R1,A
   \   0000E5   8882         MOV     DPL,R0
   \   0000E7   8983         MOV     DPH,R1
   \   0000E9   E5..         MOV     A,?V0 + 2
   \   0000EB   F0           MOVX    @DPTR,A
   \   0000EC   A3           INC     DPTR
   \   0000ED   E5..         MOV     A,?V0 + 3
   \   0000EF   F0           MOVX    @DPTR,A
    372                p3 = p1->next;
   \   0000F0   EA           MOV     A,R2
   \   0000F1   240E         ADD     A,#0xe
   \   0000F3   F582         MOV     DPL,A
   \   0000F5   EB           MOV     A,R3
   \   0000F6   3400         ADDC    A,#0x0
   \   0000F8   F583         MOV     DPH,A
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   F8           MOV     R0,A
   \   0000FC   A3           INC     DPTR
   \   0000FD   E0           MOVX    A,@DPTR
   \   0000FE   F9           MOV     R1,A
   \   0000FF   E8           MOV     A,R0
   \   000100   FC           MOV     R4,A
   \   000101   E9           MOV     A,R1
   \   000102   FD           MOV     R5,A
    373          //      osal_mem_free(((Node*)p1));
    374                if(deletnodelist ==NULL){
   \   000103   90....       MOV     DPTR,#deletnodelist
   \   000106   E0           MOVX    A,@DPTR
   \   000107   F8           MOV     R0,A
   \   000108   A3           INC     DPTR
   \   000109   E0           MOVX    A,@DPTR
   \   00010A   F9           MOV     R1,A
   \   00010B   E8           MOV     A,R0
   \   00010C   49           ORL     A,R1
   \   00010D   7021         JNZ     ??detectHandle_5
    375                  deletnodelist = p1;
   \   00010F   90....       MOV     DPTR,#deletnodelist
   \   000112   EA           MOV     A,R2
   \   000113   F0           MOVX    @DPTR,A
   \   000114   A3           INC     DPTR
   \   000115   EB           MOV     A,R3
   \   000116   F0           MOVX    @DPTR,A
    376                  deletnodelist->next = NULL;
   \   000117   90....       MOV     DPTR,#deletnodelist
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   240E         ADD     A,#0xe
   \   00011D   F8           MOV     R0,A
   \   00011E   A3           INC     DPTR
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   3400         ADDC    A,#0x0
   \   000122   F9           MOV     R1,A
   \   000123   8882         MOV     DPL,R0
   \   000125   8983         MOV     DPH,R1
   \   000127   7400         MOV     A,#0x0
   \   000129   F0           MOVX    @DPTR,A
   \   00012A   A3           INC     DPTR
   \   00012B   7400         MOV     A,#0x0
   \   00012D   F0           MOVX    @DPTR,A
   \   00012E   8067         SJMP    ??detectHandle_6
    377                }
    378                else{
    379                  p2=deletnodelist;
   \                     ??detectHandle_5:
   \   000130   90....       MOV     DPTR,#deletnodelist
   \   000133   E0           MOVX    A,@DPTR
   \   000134   F8           MOV     R0,A
   \   000135   A3           INC     DPTR
   \   000136   E0           MOVX    A,@DPTR
   \   000137   F9           MOV     R1,A
   \   000138   88..         MOV     ?V0 + 0,R0
   \   00013A   89..         MOV     ?V0 + 1,R1
    380                  while(p2->next){p2=p2->next;}
   \                     ??detectHandle_7:
   \   00013C   E5..         MOV     A,?V0 + 0
   \   00013E   240E         ADD     A,#0xe
   \   000140   F582         MOV     DPL,A
   \   000142   E5..         MOV     A,?V0 + 1
   \   000144   3400         ADDC    A,#0x0
   \   000146   F583         MOV     DPH,A
   \   000148   E0           MOVX    A,@DPTR
   \   000149   F8           MOV     R0,A
   \   00014A   A3           INC     DPTR
   \   00014B   E0           MOVX    A,@DPTR
   \   00014C   F9           MOV     R1,A
   \   00014D   E8           MOV     A,R0
   \   00014E   49           ORL     A,R1
   \   00014F   6015         JZ      ??detectHandle_8
   \   000151   E5..         MOV     A,?V0 + 0
   \   000153   240E         ADD     A,#0xe
   \   000155   F582         MOV     DPL,A
   \   000157   E5..         MOV     A,?V0 + 1
   \   000159   3400         ADDC    A,#0x0
   \   00015B   F583         MOV     DPH,A
   \   00015D   E0           MOVX    A,@DPTR
   \   00015E   F5..         MOV     ?V0 + 0,A
   \   000160   A3           INC     DPTR
   \   000161   E0           MOVX    A,@DPTR
   \   000162   F5..         MOV     ?V0 + 1,A
   \   000164   80D6         SJMP    ??detectHandle_7
    381                  p2->next = p1;
   \                     ??detectHandle_8:
   \   000166   E5..         MOV     A,?V0 + 0
   \   000168   240E         ADD     A,#0xe
   \   00016A   F582         MOV     DPL,A
   \   00016C   E5..         MOV     A,?V0 + 1
   \   00016E   3400         ADDC    A,#0x0
   \   000170   F583         MOV     DPH,A
   \   000172   EA           MOV     A,R2
   \   000173   F0           MOVX    @DPTR,A
   \   000174   A3           INC     DPTR
   \   000175   EB           MOV     A,R3
   \   000176   F0           MOVX    @DPTR,A
    382                  p2->next->next=NULL;
   \   000177   E5..         MOV     A,?V0 + 0
   \   000179   240E         ADD     A,#0xe
   \   00017B   F582         MOV     DPL,A
   \   00017D   E5..         MOV     A,?V0 + 1
   \   00017F   3400         ADDC    A,#0x0
   \   000181   F583         MOV     DPH,A
   \   000183   E0           MOVX    A,@DPTR
   \   000184   240E         ADD     A,#0xe
   \   000186   F8           MOV     R0,A
   \   000187   A3           INC     DPTR
   \   000188   E0           MOVX    A,@DPTR
   \   000189   3400         ADDC    A,#0x0
   \   00018B   F9           MOV     R1,A
   \   00018C   8882         MOV     DPL,R0
   \   00018E   8983         MOV     DPH,R1
   \   000190   7400         MOV     A,#0x0
   \   000192   F0           MOVX    @DPTR,A
   \   000193   A3           INC     DPTR
   \   000194   7400         MOV     A,#0x0
   \   000196   F0           MOVX    @DPTR,A
    383                }
    384                p1=p3;
   \                     ??detectHandle_6:
   \   000197   EC           MOV     A,R4
   \   000198   F8           MOV     R0,A
   \   000199   ED           MOV     A,R5
   \   00019A   F9           MOV     R1,A
   \   00019B   E8           MOV     A,R0
   \   00019C   FA           MOV     R2,A
   \   00019D   E9           MOV     A,R1
   \   00019E   FB           MOV     R3,A
    385                while(p3->prior != NULL)
   \                     ??detectHandle_9:
   \   00019F   EC           MOV     A,R4
   \   0001A0   2410         ADD     A,#0x10
   \   0001A2   F582         MOV     DPL,A
   \   0001A4   ED           MOV     A,R5
   \   0001A5   3400         ADDC    A,#0x0
   \   0001A7   F583         MOV     DPH,A
   \   0001A9   E0           MOVX    A,@DPTR
   \   0001AA   F8           MOV     R0,A
   \   0001AB   A3           INC     DPTR
   \   0001AC   E0           MOVX    A,@DPTR
   \   0001AD   F9           MOV     R1,A
   \   0001AE   E8           MOV     A,R0
   \   0001AF   49           ORL     A,R1
   \   0001B0   6011         JZ      ??detectHandle_10
    386                  p3 = p3->prior;
   \   0001B2   EC           MOV     A,R4
   \   0001B3   2410         ADD     A,#0x10
   \   0001B5   F582         MOV     DPL,A
   \   0001B7   ED           MOV     A,R5
   \   0001B8   3400         ADDC    A,#0x0
   \   0001BA   F583         MOV     DPH,A
   \   0001BC   E0           MOVX    A,@DPTR
   \   0001BD   FC           MOV     R4,A
   \   0001BE   A3           INC     DPTR
   \   0001BF   E0           MOVX    A,@DPTR
   \   0001C0   FD           MOV     R5,A
   \   0001C1   80DC         SJMP    ??detectHandle_9
    387                *pNode = p3;
   \                     ??detectHandle_10:
   \   0001C3   8E82         MOV     DPL,R6
   \   0001C5   8F83         MOV     DPH,R7
   \   0001C7   EC           MOV     A,R4
   \   0001C8   F0           MOVX    @DPTR,A
   \   0001C9   A3           INC     DPTR
   \   0001CA   ED           MOV     A,R5
   \   0001CB   F0           MOVX    @DPTR,A
    388          //      (*pNode)->extaddr[2] = 0xff;
    389                //gizwit_status = 0;//发送给机智云状态数据
    390                continue;
   \   0001CC   02....       LJMP    ??detectHandle_0 & 0xFFFF
    391              }
    392              p1 = p1->next;
   \                     ??detectHandle_4:
   \   0001CF   EA           MOV     A,R2
   \   0001D0   240E         ADD     A,#0xe
   \   0001D2   F582         MOV     DPL,A
   \   0001D4   EB           MOV     A,R3
   \   0001D5   3400         ADDC    A,#0x0
   \   0001D7   F583         MOV     DPH,A
   \   0001D9   E0           MOVX    A,@DPTR
   \   0001DA   FA           MOV     R2,A
   \   0001DB   A3           INC     DPTR
   \   0001DC   E0           MOVX    A,@DPTR
   \   0001DD   FB           MOV     R3,A
   \   0001DE   02....       LJMP    ??detectHandle_0 & 0xFFFF
    393            }
    394          //  *pNode = p2;
    395            return 1;
   \                     ??detectHandle_1:
   \   0001E1   7901         MOV     R1,#0x1
   \   0001E3   7F04         MOV     R7,#0x4
   \   0001E5   02....       LJMP    ?BANKED_LEAVE_XDATA
    396          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E8           MOV     A,R0
   \   000001   240B         ADD     A,#0xb
   \   000003   F582         MOV     DPL,A
   \   000005   E9           MOV     A,R1
   \   000006                REQUIRE ??Subroutine14_0
   \   000006                ; // Fall through to label ??Subroutine14_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    397          uint8 mac_table_fresh( afIncomingMSGPacket_t *pkt )
   \                     mac_table_fresh:
    398          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    399          //  uint8 currentMac[8];
    400            Node *currentnode;
    401            if( (pkt->cmd.Data[0])==0 || (pkt->cmd.Data[0])==2 ){// 发现请求建立数据包和心跳包时更新mac list table
   \   000009   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F8           MOV     R0,A
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F583         MOV     DPH,A
   \   000012   8882         MOV     DPL,R0
   \   000014   E0           MOVX    A,@DPTR
   \   000015   6011         JZ      ??mac_table_fresh_0
   \   000017   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F583         MOV     DPH,A
   \   00001E   8882         MOV     DPL,R0
   \   000020   E0           MOVX    A,@DPTR
   \   000021   6402         XRL     A,#0x2
   \   000023   6003         JZ      $+5
   \   000025   02....       LJMP    ??mac_table_fresh_1 & 0xFFFF
    402              if(true == APSME_LookupExtAddr(pkt->srcAddr.addr.shortAddr,currentMac)){
   \                     ??mac_table_fresh_0:
   \   000028                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000028   7C..         MOV     R4,#currentMac & 0xff
   \   00002A   7D..         MOV     R5,#(currentMac >> 8) & 0xff
   \   00002C   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   00002F   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   000032   E9           MOV     A,R1
   \   000033   6401         XRL     A,#0x1
   \   000035   7044         JNZ     ??mac_table_fresh_2
    403                currentnode = searchfromList(nodelist,currentMac);
   \   000037                ; Setup parameters for call to function searchfromList
   \   000037   7C..         MOV     R4,#currentMac & 0xff
   \   000039   7D..         MOV     R5,#(currentMac >> 8) & 0xff
   \   00003B   90....       MOV     DPTR,#nodelist
   \   00003E   12....       LCALL   ??Subroutine17_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000041   12....       LCALL   ??searchfromList?relay
   \   000044   8A..         MOV     ?V0 + 0,R2
   \   000046   8B..         MOV     ?V0 + 1,R3
   \   000048   A8..         MOV     R0,?V0 + 0
   \   00004A   A9..         MOV     R1,?V0 + 1
    404                if(currentnode == NULL){
   \   00004C   E8           MOV     A,R0
   \   00004D   49           ORL     A,R1
   \   00004E   7023         JNZ     ??mac_table_fresh_3
    405                  newdevice_joinin = insertLastList(&nodelist,currentMac,pkt->srcAddr.addr.shortAddr);
   \   000050                ; Setup parameters for call to function insertLastList
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00005D   7C..         MOV     R4,#currentMac & 0xff
   \   00005F   7D..         MOV     R5,#(currentMac >> 8) & 0xff
   \   000061   7A..         MOV     R2,#nodelist & 0xff
   \   000063   7B..         MOV     R3,#(nodelist >> 8) & 0xff
   \   000065   12....       LCALL   ??insertLastList?relay
   \   000068   7402         MOV     A,#0x2
   \   00006A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006D   E9           MOV     A,R1
   \   00006E   90....       MOV     DPTR,#newdevice_joinin
   \   000071   8003         SJMP    ??CrossCallReturnLabel_19
    406          //        newdevice_joinin = 1;
    407                }
    408                else
    409                  currentnode->heartbeatCnt++;
   \                     ??mac_table_fresh_3:
   \   000073   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000076   F0           MOVX    @DPTR,A
    410                return 0;//找到设备mac
   \   000077   7900         MOV     R1,#0x0
   \   000079   803D         SJMP    ??mac_table_fresh_4
    411              }
    412              else if(currentnode=searchshortaddfromList(nodelist,pkt->srcAddr.addr.shortAddr)){
   \                     ??mac_table_fresh_2:
   \   00007B                ; Setup parameters for call to function searchshortaddfromList
   \   00007B   8E82         MOV     DPL,R6
   \   00007D   8F83         MOV     DPH,R7
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   FC           MOV     R4,A
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   FD           MOV     R5,A
   \   00008A   90....       MOV     DPTR,#nodelist
   \   00008D   12....       LCALL   ??Subroutine17_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000090   12....       LCALL   ??searchshortaddfromList?relay
   \   000093   8A..         MOV     ?V0 + 0,R2
   \   000095   8B..         MOV     ?V0 + 1,R3
   \   000097   A8..         MOV     R0,?V0 + 0
   \   000099   A9..         MOV     R1,?V0 + 1
   \   00009B   E8           MOV     A,R0
   \   00009C   49           ORL     A,R1
   \   00009D   6005         JZ      ??mac_table_fresh_5
    413                currentnode->heartbeatCnt++;
   \   00009F   12....       LCALL   ?Subroutine7 & 0xFFFF
    414              }
   \                     ??CrossCallReturnLabel_20:
   \   0000A2   8011         SJMP    ??mac_table_fresh_6
    415              else{
    416                ZDP_IEEEAddrReq(pkt->srcAddr.addr.shortAddr , ZDP_ADDR_REQTYPE_SINGLE, 0 ,0 );
   \                     ??mac_table_fresh_5:
   \   0000A4                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   0000A4   7D00         MOV     R5,#0x0
   \   0000A6   7C00         MOV     R4,#0x0
   \   0000A8   7900         MOV     R1,#0x0
   \   0000AA   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   0000AD   12....       LCALL   ??ZDP_IEEEAddrReq?relay
    417                newdevice_joinin = 3;//无法找到mac
   \   0000B0   90....       MOV     DPTR,#newdevice_joinin
   \   0000B3   7403         MOV     A,#0x3
   \                     ??mac_table_fresh_6:
   \   0000B5   F0           MOVX    @DPTR,A
    418          //      HalUARTWrite(0,"LookupExtAddr err\r\n",19);
    419              }
    420            }
    421            return 1;//找不到设备mac
   \                     ??mac_table_fresh_1:
   \   0000B6   7901         MOV     R1,#0x1
   \                     ??mac_table_fresh_4:
   \   0000B8   7F02         MOV     R7,#0x2
   \   0000BA   02....       LJMP    ?BANKED_LEAVE_XDATA
    422          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   EE           MOV     A,R6
   \   000001   2422         ADD     A,#0x22
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \   000006   12....       LCALL   ??Subroutine15_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A                REQUIRE ??Subroutine17_0
   \   00000A                ; // Fall through to label ??Subroutine17_0

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??initList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    initList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??searchfromList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    searchfromList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??searchshortaddfromList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    searchshortaddfromList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??insertLastList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    insertLastList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??detectHandle?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    detectHandle

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mac_table_fresh?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mac_table_fresh

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {48, 49, 50, 51, 52, 53, 54, 55, 56`:
   \   000000   30           DB 48
   \   000001   31           DB 49
   \   000002   32           DB 50
   \   000003   33           DB 51
   \   000004   34           DB 52
   \   000005   35           DB 53
   \   000006   36           DB 54
   \   000007   37           DB 55
   \   000008   38           DB 56
   \   000009   39           DB 57
   \   00000A   41           DB 65
   \   00000B   42           DB 66
   \   00000C   43           DB 67
   \   00000D   44           DB 68
   \   00000E   45           DB 69
   \   00000F   46           DB 70

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "\\r\\nlist memalloc error">`:
   \   000000   0D0A6C69     DB "\015\012list memalloc error"
   \            7374206D
   \            656D616C
   \            6C6F6320
   \            6572726F
   \            7200    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "\\nA:">`:
   \   000000   0A413A00     DB "\012A:"

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "\\n">`:
   \   000000   0A00         DB "\012"
    423          //uint8 deleteOneList(Node *pNode,elemType insertElem)
    424          //{
    425          //  Node *pInsert;
    426          //  Node *pHead;
    427          //  Node *pTmp; //定义一个临时链表用来存放第一个节点
    428          //  
    429          //  pHead = pNode;
    430          //  pTmp = pHead;
    431          //  pInsert = (Node *)osal_mem_alloc(sizeof(Node)); //申请一个新节点
    432          //  osal_memset(pInsert,0,sizeof(Node));
    433          //  pInsert->element = insertElem;
    434          //  
    435          //  while(pHead->next != NULL)
    436          //  {
    437          //    pHead = pHead->next;
    438          //  }
    439          //  pHead->next = pInsert;   //将链表末尾节点的下一结点指向新添加的节点
    440          //  pNode = pTmp;
    441          //  //pruint8f("insertLastList函数执行，向表尾插入元素成功\n");
    442          //  
    443          //  return 1;
    444          //}

   Maximum stack usage in bytes:

     Function                    ISTACK PSTACK XSTACK
     --------                    ------ ------ ------
     detectHandle                    1      0     12
     initList                        2      0      0
     insertLastList                  2      0     53
       -> osal_mem_alloc             0      0     76
       -> HalUARTWrite               0      0     76
       -> osal_memcpy                0      0     82
       -> HalUARTWrite               0      0     76
       -> HalUARTWrite               0      0     76
       -> HalUARTWrite               0      0     76
       -> HalUARTWrite               0      0     76
       -> osal_mem_alloc             0      0     76
       -> osal_memcpy                0      0     82
       -> HalUARTWrite               0      0     76
       -> HalUARTWrite               0      0     76
       -> HalUARTWrite               0      0     76
     mac_table_fresh                 0      0     12
       -> APSME_LookupExtAddr        0      0     20
       -> searchfromList             0      0     20
       -> insertLastList             0      0     24
       -> searchshortaddfromList     0      0     20
       -> ZDP_IEEEAddrReq            0      0     20
     searchfromList                  0      0     28
       -> osal_memcmp                0      0     36
     searchshortaddfromList          2      0     10


   Segment part sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     currentMac                                        8
     NewMacUpate                                       1
     initList                                         25
     ?Subroutine0                                      7
     ?Subroutine2                                      3
     ??Subroutine13_0                                  6
     ?Subroutine10                                    13
     searchfromList                                  102
     ??Subroutine14_0                                  6
     ??Subroutine15_0                                  5
     searchshortaddfromList                           65
     ??Subroutine17_0                                  6
     insertLastList                                  474
     ?Subroutine11                                     8
     ?Subroutine8                                      5
     ?Subroutine6                                      3
     ??Subroutine16_0                                  6
     ?Subroutine4                                     13
     ?Subroutine3                                     11
     ?Subroutine1                                     46
     ?Subroutine12                                    24
     detectHandle                                    488
     ?Subroutine7                                      6
     mac_table_fresh                                 189
     ?Subroutine9                                     10
     ?Subroutine5                                     10
     ??initList?relay                                  6
     ??searchfromList?relay                            6
     ??searchshortaddfromList?relay                    6
     ??insertLastList?relay                            6
     ??detectHandle?relay                              6
     ??mac_table_fresh?relay                           6
     ?<Constant {48, 49, 50, 51, 52, 53, 54, 55, 56   16
     ?<Constant "\r\nlist memalloc error">            22
     ?<Constant "\nA:">                                4
     ?<Constant "\n">                                  2

 
 1 531 bytes in segment BANKED_CODE
    36 bytes in segment BANK_RELAYS
    44 bytes in segment XDATA_ROM_C
     9 bytes in segment XDATA_Z
 
 1 567 bytes of CODE  memory
    44 bytes of CONST memory
     9 bytes of XDATA memory

Errors: none
Warnings: none
